{
  "name": "put-selector",
  "author": {
    "name": "Kris Zyp"
  },
  "version": "0.3.6",
  "description": "A high-performance, lightweight function for creating and manipulating DOM elements with succinct, elegant, familiar CSS selector-based syntax",
  "licenses": [
    {
      "type": "AFLv2.1",
      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L43"
    },
    {
      "type": "BSD",
      "url": "http://trac.dojotoolkit.org/browser/dojo/trunk/LICENSE#L13"
    }
  ],
  "maintainers": [
    {
      "name": "Kris Zyp",
      "email": "kriszyp@gmail.com"
    }
  ],
  "directories": {
    "lib": "."
  },
  "main": "./put",
  "icon": "http://packages.dojofoundation.org/images/xstyle.jpg",
  "dojoBuild": "package.js",
  "readme": "This put-selector/put module/package provides a high-performance, lightweight \n(~2KB minified, ~1KB gzipped with other code) function for creating \nand manipulating DOM elements with succinct, elegant, familiar CSS selector-based \nsyntax across all browsers and platforms (including HTML generation on NodeJS). \nThe single function from the module creates or updates DOM elements by providing\na series of arguments that can include reference elements, selector strings, properties,\nand text content. The put() function utilizes the proven techniques for optimal performance\non modern browsers to ensure maximum speed.\n\nInstallation/Usage\n----------------\n\nThe put.js module can be simply downloaded and used a plain script (creates a global \nput() function), as an AMD module (exports the put() function), or as a NodeJS (or any\nserver side JS environment) module.\nIt can also be installed with <a href=\"https://github.com/kriszyp/cpm\">CPM</a>:\n\n\tcpm install put-selector\n\nand then reference the \"put-selector\" module as a dependency.\nor installed for Node with NPM:\n\n\tnpm install put-selector\n\nand then:\n\n\tput = require(\"put-selector\");\n\nCreating Elements\n----------------\n\nType selector syntax (no prefix) can be used to indicate the type of element to be created. For example:\n\n\tnewDiv = put(\"div\");\n\t\nwill create a new &lt;div> element. We can put a reference element in front of the selector\nstring and the &lt;div> will be appended as a child to the provided element: \n\n\tput(parent, \"div\"); \n\t\nThe selector .class-name can be used to assign the class name. For example:\n\n\tput(\"div.my-class\") \n\t\nwould create an element &lt;div class=\"my-class\"> (an element with a class of \"my-class\").\n\nThe selector #id can be used to assign an id and [name=value] can be used to \nassign additional attributes to the element. For example:\n\n\tnewInput = put(parent, \"input.my-input#address[type=checkbox]\");\n\nWould create an input element with a class name of \"my-input\", an id of \"address\",\nand the type attribute set to \"checkbox\". The attribute assignment will always use \nsetAttribute to assign the attribute to the element. Multiple attributes and classes\ncan be assigned to a single element. \n\nThe put function returns the last top level element created or referenced from a selector. \nIn the examples above, the newly create element would be returned. Note that passing \nin an existing node will not change the return value (as it is assumed you already have \na reference to it). Also note that if you only pass existing nodes reference, the first \npassed reference will be returned.\n\nModifying Elements\n----------------\n\nOne can also modify elements with selectors. If the tag name is omitted (and no\ncombinators have been used), the reference element will be modified by the selector.\nFor example, to add the class \"foo\" to element, we could write:\n\n\tput(element, \".foo\"); \n\nLikewise, we could set attributes, here we set the \"role\" attribute to \"presentation\":\n\n\tput(element, \"[role=presentation]\");\n\nAnd these can be combined also. For example, we could set the id and an attribute in\none statement:\n\n\tput(element, \"#id[tabIndex=2]\");\n\nOne can also remove classes from elements by using the \"!\" operator in place of a \".\". \nTo remove the \"foo\" class from an element, we could write:\n\n\tput(element, \"!foo\");\n\nWe can also use the \"!\" operator to remove attributes as well. Prepending an attribute name\nwith \"!\" within brackets will remove it. To remove the \"role\" attribute, we could write:\n\n\tput(element, \"[!role]\");\n\nDeleting Elements\n--------------\n\nTo delete an element, we can simply use the \"!\" operator by itself as the entire selector:\n\n\tput(elementToDelete, \"!\");\n\nThis will destroy the element from the DOM, using either parent innerHTML destruction (IE only, that \nreduces memory leaks in IE), or removeChild (for all other browsers).\n\nCreating/Modifying Elements with XML Namespaces\n-----------\n\nTo work with elements and attributes that are XML namespaced, start by adding the namespace using addNamespace:\n\n\tput.addNamespace(\"svg\", \"http://www.w3.org/2000/svg\");\n\tput.addNamespace(\"xlink\", \"http://www.w3.org/1999/xlink\");\n\nFrom there, you can use the CSS3 selector syntax to work with elements and attributes:\n\n\tvar surface = put(\"svg|svg[width='100'][height='100']\");\n\tvar img = put(surface, \"svg|image[xlink|href='path/to/my/image.png']\");\n\nText Content\n-----------\n\nThe put() arguments may also include a subsequent string (or any primitive value including\nboolean and numbers) argument immediately \nfollowing a selector, in which case it is used as the text inside of the new/referenced element.\nFor example, here we could create a new &lt;div> with the text \"Hello, World\" inside.\n\n\tnewDiv = put(parent, \"div\", \"Hello, World\");\n\nThe text is escaped, so any string will show up as is, and will not be parsed as HTML.\n\nChildren and Combinators\n-----------------------\n\nCSS combinators can be used to create child elements and sibling elements. For example,\nwe can use the child operator (or the descendant operator, it acts the same here) to \ncreate nested elements:\n\n\tspanInsideOfDiv = put(reference, \"div.outer span.inner\");\n\nThis would create a new span element (with a class name of \"inner\") as a child of a\nnew div element (with a class name of \"outer\") as a child of the reference element. The\nspan element would be returned. We can also use the sibling operator to reference\nthe last created element or the reference element. In the example we indicate that\nwe want to create sibling of the reference element:\n\n\tnewSpan = put(reference, \"+span\");\n\nWould create a new span element directly after the reference element (reference and \nnewSpan would be siblings.) We can also use the \"-\" operator to indicate that the new element\nshould go before: \n\n\tnewSpan = put(reference, \"-span\");\n\nThis new span element will be inserted before the reference element in the DOM order.\nNote that \"-\" is valid character in tags and classes, so it will only be interpreted as a\ncombinator if it is the first character or if it is preceded by a space.\n\nThe sibling operator can reference the last created element as well. For example\nto add two td element to a table row:\n\n\tput(tableRow, \"td+td\");\n\nThe last created td will be returned.\n\nThe parent operator, \"<\" can be used to reference the parent of the last created \nelement or reference element. In this example, we go crazy, and create a full table,\nusing the parent operator (applied twice) to traverse back up the DOM to create another table row\nafter creating a td element:\n\n\tnewTable = put(referenceElement, \"table.class-name#id tr td[colSpan=2]<<tr td+td<<\");\n\nWe also use a parent operator twice at the end, so that we move back up two parents \nto return the table element (instead of the td element).\n\nFinally, we can use the comma operator to create multiple elements, each basing their selector \nscope on the reference element. For example we could add two more rows to our table\nwithout having to use the double parent operator:\n\n\tput(newTable, \"tr td,tr td+td\");\n\nAppending/Inserting Existing Elements\n---------------------------------\n\nExisting elements may be referenced in the arguments after selectors as well as before.\nIf an existing element is included in the arguments after a selector, the existing element will\nbe appended to the last create/referenced element or it will be inserted according to\na trailing combinator. For example, we could create a &lt;div> and then append \nthe \"child\" element to the new &lt;div>: \n\n\tput(\"div\", child);\n\nOr we can do a simple append of an existing element to another element:\n\n\tput(parent, child);\n\nWe could also do this more explicitly by using a child descendant, '>' (which has the\nsame meaning as a space operator, and is the default action between arguments in put-selector):\n\n\tput(parent, \">\", child);\n\nWe could also use sibling combinators to place the referenced element. We could place\nthe \"second\" element after (as the next sibling) the \"first\" element (which needs a parent\nin order to have a sibling):\n \n\tput(first, \"+\", second);\n\nOr we could create a &lt;div> and place \"first\" before it using the previous sibling combinator:\n\n\tput(parent, \"div.second -\", first);\n\nThe put() function takes an unlimited number of arguments, so we could combine as\nmany selectors and elements as we want: \n\n\tput(parent, \"div.child\", grandchild, \"div.great-grandchild\", gggrandchild);\n\t\nVariable Substitution\n-------------------\n\nThe put() function also supports variable substitution, by using the \"$\" symbol in selectors.\nThe \"$\" can be used for attribute values and to represent text content. When a \"$\"\nis encountered in a selector, the next argument value is consumed and used in it's\nplace. To create an element with a title that comes from the variable \"title\", we could write:\n\n\tput(\"div[title=$]\", title);\n\nThe value of title may have any characters (including ']'), no escaping is needed. \nThis approach can simplify selector string construction and avoids the need for complicated\nescaping mechanisms.\n\nThe \"$\" may be used as a child entity to indicate text content. For example, we could\ncreate a set of &lt;span> element that each have content to be substituted:\n\n\tput(\"span.first-name $, span.last-name $, span.age $\", firstName, lastName, age);\n\nAssigning Properties\n------------------\n\nThe put() function can also take an object with properties to be set on the new/referenced\nelement. For example, we could write:\n\n\tnewDiv = put(parent, \"div\", {\n\t\ttabIndex: 1,\n\t\tinnerHTML: \"Hello, World\"\n\t});\n\nWhich is identical to writing (all the properties are set using direct property access, not setAttribute):\n\n\tnewDiv = put(parent, \"div\");\n\tnewDiv.tabIndex = 1;\n\tnewDiv.innerHTML = \"Hello, World\";\n\nNodeJS/Server Side HTML Generation\n----------------------------\n\nWhile the put() function directly creates DOM elements in the browser, the put() function\ncan be used to generate HTML on the server, in NodeJS. When no DOM is available, \na fast lightweight pseudo-DOM is created that can generate HTML as a string or into a stream.\nThe API is still the same, but the put() function returns pseudo-elements with a \ntoString() method that can be called to return the HTML and sendTo method to direct\ngenerated elements to a stream on the fly. For example:\n\n\tput(\"div.test\").toString() -> '<div class=\"test\"></div>' \n\nTo use put() streaming, we create and element and call sendTo with a target stream.\nIn streaming mode, the elements are written to the stream as they are added to the\nparent DOM structure. This approach is much more efficient because very little\nneeds to be kept in memory, the HTML can be immediately flushed to the network as it is created.\nOnce an element is added to the streamed DOM structure,\nit is immediately sent to the stream, and it's attributes and classes can no longer be\naltered. There are two methods on elements available for streaming purposes:\n\n\telement.sendTo(stream)\n\t\nThe sendTo(stream) method will begin streaming the element to the target stream,\nand any children that are added to the element will be streamed as well.\n\n\telement.end(leaveOpen) \n\nThe end(leaveOpen) method will end the current streaming, closing all the necessary\ntags and closing the stream (unless the argument is true). \n\nThe returned elements also include a put() method so you can directly add to or apply\nCSS selector-based additions to elements, for example:\n\n\telement.put('div.test'); // create a &lt;div class=\"test\">&lt;/div> as a child of element\n\nHere is an example of how we could create a full page in NodeJS that is streamed to \nthe response:\n\n\tvar http = require('http');\n\tvar put = require('put-selector');\n\thttp.createServer(function (req, res) {\n\t\tres.writeHead(200, {'Content-Type': 'text/html'});\n\t\tvar page = put('html').sendTo(res); // create an HTML page, and pipe to the response \n\t\tpage.put('head script[src=app.js]'); // each element is sent immediately\n\t\tpage.put('body div.content', 'Hello, World');\n\t\tpage.end(); // close all the tags, and end the stream\n\t}).listen(80);\n\nOn the server, there are some limitations to put(). The server side DOM emulation\nis designed to be very fast and light and therefore omits much of the standard DOM\nfunctionality, and only what is needed for put() is implemented. Elements can\nnot be moved or removed. DOM creation and updating is still supported in string\ngeneration mode, but only creation is supported in streaming mode. Also, setting \nobject properties is mostly ignored (because only attributes are part of HTML), except\nyou can set the innerHTML of an element. \n\nProper Creation of Inputs\n-------------------------\n\nOlder versions of Internet Explorer have a bug in assigning a \"name\" attribute to input after it\nhas been created, and requires a special creation technique. The put() function handles\nthis for you as long as you specify the name of the input in the property assignment\nobject after the selector string. For example, this input creation will properly work\non all browsers, including IE:\n\n\tnewInput = put(\"input[type=checkbox]\", {name: \"works\"});\n\nUsing on Different document\n-------------------------\n\nIf you are using multiple frames in your web page, you may encounter a situation where\nyou want to use put-selector to make DOM changes on a different HTML document.\nYou can create a separate instance of the put() function for a separate document by\ncalling the put.forDocument(document) function. For example:\n\n\tput2 = put.forDocument(frames[1].document);\n\tput2(\"div\") <- creates a div element that belongs to the document in the second frame.\n\tput(\"div\") <- the original put still functions on the main document for this window/context \n\n# License\n\nput-selector is freely available under *either* the terms of the modified BSD license *or* the\nAcademic Free License version 2.1. More details can be found in the [LICENSE](LICENSE).\nThe put-selector project follows the IP guidelines of Dojo foundation packages and all contributions require a Dojo CLA. \nIf you feel compelled to make a monetary contribution, consider some of the author's [favorite\ncharities](http://thezyps.com/2012-giving-guide/) like [Innovations for Poverty Action](http://www.poverty-action.org/).",
  "readmeFilename": "README.md",
  "_id": "put-selector@0.3.6",
  "dist": {
    "shasum": "d5f812e83928569f386d83cf3d1ba16b97c4bd19"
  },
  "_from": "https://github.com/Scimonster/put-selector/archive/0.3.6.tar.gz",
  "_resolved": "https://github.com/Scimonster/put-selector/archive/0.3.6.tar.gz"
}
